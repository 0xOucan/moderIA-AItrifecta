"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ofetch";
exports.ids = ["vendor-chunks/ofetch"];
exports.modules = {

/***/ "(ssr)/./node_modules/ofetch/dist/node.mjs":
/*!*******************************************!*\
  !*** ./node_modules/ofetch/dist/node.mjs ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $fetch: () => (/* binding */ $fetch),\n/* harmony export */   AbortController: () => (/* binding */ AbortController),\n/* harmony export */   FetchError: () => (/* reexport safe */ _shared_ofetch_03887fc3_mjs__WEBPACK_IMPORTED_MODULE_3__.F),\n/* harmony export */   Headers: () => (/* binding */ Headers),\n/* harmony export */   createFetch: () => (/* reexport safe */ _shared_ofetch_03887fc3_mjs__WEBPACK_IMPORTED_MODULE_3__.c),\n/* harmony export */   createFetchError: () => (/* reexport safe */ _shared_ofetch_03887fc3_mjs__WEBPACK_IMPORTED_MODULE_3__.a),\n/* harmony export */   createNodeFetch: () => (/* binding */ createNodeFetch),\n/* harmony export */   fetch: () => (/* binding */ fetch),\n/* harmony export */   ofetch: () => (/* binding */ ofetch)\n/* harmony export */ });\n/* harmony import */ var node_http__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:http */ \"node:http\");\n/* harmony import */ var node_https__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node:https */ \"node:https\");\n/* harmony import */ var node_fetch_native__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! node-fetch-native */ \"(ssr)/./node_modules/node-fetch-native/dist/index.mjs\");\n/* harmony import */ var _shared_ofetch_03887fc3_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./shared/ofetch.03887fc3.mjs */ \"(ssr)/./node_modules/ofetch/dist/shared/ofetch.03887fc3.mjs\");\n/* harmony import */ var destr__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! destr */ \"(ssr)/./node_modules/destr/dist/index.mjs\");\n\n\n\n\n\n\n\n\nfunction createNodeFetch() {\n  const useKeepAlive = JSON.parse(process.env.FETCH_KEEP_ALIVE || \"false\");\n  if (!useKeepAlive) {\n    return node_fetch_native__WEBPACK_IMPORTED_MODULE_2__[\"default\"];\n  }\n  const agentOptions = { keepAlive: true };\n  const httpAgent = new node_http__WEBPACK_IMPORTED_MODULE_0__.Agent(agentOptions);\n  const httpsAgent = new node_https__WEBPACK_IMPORTED_MODULE_1__.Agent(agentOptions);\n  const nodeFetchOptions = {\n    agent(parsedURL) {\n      return parsedURL.protocol === \"http:\" ? httpAgent : httpsAgent;\n    }\n  };\n  return function nodeFetchWithKeepAlive(input, init) {\n    return (0,node_fetch_native__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(input, { ...nodeFetchOptions, ...init });\n  };\n}\nconst fetch = globalThis.fetch ? (...args) => globalThis.fetch(...args) : createNodeFetch();\nconst Headers = globalThis.Headers || node_fetch_native__WEBPACK_IMPORTED_MODULE_2__.Headers;\nconst AbortController = globalThis.AbortController || node_fetch_native__WEBPACK_IMPORTED_MODULE_2__.AbortController;\nconst ofetch = (0,_shared_ofetch_03887fc3_mjs__WEBPACK_IMPORTED_MODULE_3__.c)({ fetch, Headers, AbortController });\nconst $fetch = ofetch;\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb2ZldGNoL2Rpc3Qvbm9kZS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBNkI7QUFDRTtBQUMyRTtBQUMxQztBQUNzQjtBQUN2RTtBQUNGOztBQUViO0FBQ0E7QUFDQTtBQUNBLFdBQVcseURBQVM7QUFDcEI7QUFDQSx5QkFBeUI7QUFDekIsd0JBQXdCLDRDQUFVO0FBQ2xDLHlCQUF5Qiw2Q0FBVztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDZEQUFTLFVBQVUsOEJBQThCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxzREFBUztBQUMvQyxzREFBc0QsOERBQWlCO0FBQ3ZFLGVBQWUsOERBQVcsR0FBRyxpQ0FBaUM7QUFDOUQ7O0FBRXlGIiwic291cmNlcyI6WyIvVXNlcnMvYXJpaWVsbHVzZGV2L0RvY3VtZW50cy9EZXZPcHMvSGFja2F0aG9uL21vZGVySUEtQUl0cmlmZWN0YS9ub2RlX21vZHVsZXMvb2ZldGNoL2Rpc3Qvbm9kZS5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGh0dHAgZnJvbSAnbm9kZTpodHRwJztcbmltcG9ydCBodHRwcyBmcm9tICdub2RlOmh0dHBzJztcbmltcG9ydCBub2RlRmV0Y2gsIHsgSGVhZGVycyBhcyBIZWFkZXJzJDEsIEFib3J0Q29udHJvbGxlciBhcyBBYm9ydENvbnRyb2xsZXIkMSB9IGZyb20gJ25vZGUtZmV0Y2gtbmF0aXZlJztcbmltcG9ydCB7IGMgYXMgY3JlYXRlRmV0Y2ggfSBmcm9tICcuL3NoYXJlZC9vZmV0Y2guMDM4ODdmYzMubWpzJztcbmV4cG9ydCB7IEYgYXMgRmV0Y2hFcnJvciwgYSBhcyBjcmVhdGVGZXRjaEVycm9yIH0gZnJvbSAnLi9zaGFyZWQvb2ZldGNoLjAzODg3ZmMzLm1qcyc7XG5pbXBvcnQgJ2Rlc3RyJztcbmltcG9ydCAndWZvJztcblxuZnVuY3Rpb24gY3JlYXRlTm9kZUZldGNoKCkge1xuICBjb25zdCB1c2VLZWVwQWxpdmUgPSBKU09OLnBhcnNlKHByb2Nlc3MuZW52LkZFVENIX0tFRVBfQUxJVkUgfHwgXCJmYWxzZVwiKTtcbiAgaWYgKCF1c2VLZWVwQWxpdmUpIHtcbiAgICByZXR1cm4gbm9kZUZldGNoO1xuICB9XG4gIGNvbnN0IGFnZW50T3B0aW9ucyA9IHsga2VlcEFsaXZlOiB0cnVlIH07XG4gIGNvbnN0IGh0dHBBZ2VudCA9IG5ldyBodHRwLkFnZW50KGFnZW50T3B0aW9ucyk7XG4gIGNvbnN0IGh0dHBzQWdlbnQgPSBuZXcgaHR0cHMuQWdlbnQoYWdlbnRPcHRpb25zKTtcbiAgY29uc3Qgbm9kZUZldGNoT3B0aW9ucyA9IHtcbiAgICBhZ2VudChwYXJzZWRVUkwpIHtcbiAgICAgIHJldHVybiBwYXJzZWRVUkwucHJvdG9jb2wgPT09IFwiaHR0cDpcIiA/IGh0dHBBZ2VudCA6IGh0dHBzQWdlbnQ7XG4gICAgfVxuICB9O1xuICByZXR1cm4gZnVuY3Rpb24gbm9kZUZldGNoV2l0aEtlZXBBbGl2ZShpbnB1dCwgaW5pdCkge1xuICAgIHJldHVybiBub2RlRmV0Y2goaW5wdXQsIHsgLi4ubm9kZUZldGNoT3B0aW9ucywgLi4uaW5pdCB9KTtcbiAgfTtcbn1cbmNvbnN0IGZldGNoID0gZ2xvYmFsVGhpcy5mZXRjaCA/ICguLi5hcmdzKSA9PiBnbG9iYWxUaGlzLmZldGNoKC4uLmFyZ3MpIDogY3JlYXRlTm9kZUZldGNoKCk7XG5jb25zdCBIZWFkZXJzID0gZ2xvYmFsVGhpcy5IZWFkZXJzIHx8IEhlYWRlcnMkMTtcbmNvbnN0IEFib3J0Q29udHJvbGxlciA9IGdsb2JhbFRoaXMuQWJvcnRDb250cm9sbGVyIHx8IEFib3J0Q29udHJvbGxlciQxO1xuY29uc3Qgb2ZldGNoID0gY3JlYXRlRmV0Y2goeyBmZXRjaCwgSGVhZGVycywgQWJvcnRDb250cm9sbGVyIH0pO1xuY29uc3QgJGZldGNoID0gb2ZldGNoO1xuXG5leHBvcnQgeyAkZmV0Y2gsIEFib3J0Q29udHJvbGxlciwgSGVhZGVycywgY3JlYXRlRmV0Y2gsIGNyZWF0ZU5vZGVGZXRjaCwgZmV0Y2gsIG9mZXRjaCB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ofetch/dist/node.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/ofetch/dist/shared/ofetch.03887fc3.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/ofetch/dist/shared/ofetch.03887fc3.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   F: () => (/* binding */ FetchError),\n/* harmony export */   a: () => (/* binding */ createFetchError),\n/* harmony export */   c: () => (/* binding */ createFetch)\n/* harmony export */ });\n/* harmony import */ var destr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! destr */ \"(ssr)/./node_modules/destr/dist/index.mjs\");\n/* harmony import */ var ufo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ufo */ \"(ssr)/./node_modules/ufo/dist/index.mjs\");\n\n\n\nclass FetchError extends Error {\n  constructor(message, opts) {\n    super(message, opts);\n    this.name = \"FetchError\";\n    if (opts?.cause && !this.cause) {\n      this.cause = opts.cause;\n    }\n  }\n}\nfunction createFetchError(ctx) {\n  const errorMessage = ctx.error?.message || ctx.error?.toString() || \"\";\n  const method = ctx.request?.method || ctx.options?.method || \"GET\";\n  const url = ctx.request?.url || String(ctx.request) || \"/\";\n  const requestStr = `[${method}] ${JSON.stringify(url)}`;\n  const statusStr = ctx.response ? `${ctx.response.status} ${ctx.response.statusText}` : \"<no response>\";\n  const message = `${requestStr}: ${statusStr}${errorMessage ? ` ${errorMessage}` : \"\"}`;\n  const fetchError = new FetchError(\n    message,\n    ctx.error ? { cause: ctx.error } : void 0\n  );\n  for (const key of [\"request\", \"options\", \"response\"]) {\n    Object.defineProperty(fetchError, key, {\n      get() {\n        return ctx[key];\n      }\n    });\n  }\n  for (const [key, refKey] of [\n    [\"data\", \"_data\"],\n    [\"status\", \"status\"],\n    [\"statusCode\", \"status\"],\n    [\"statusText\", \"statusText\"],\n    [\"statusMessage\", \"statusText\"]\n  ]) {\n    Object.defineProperty(fetchError, key, {\n      get() {\n        return ctx.response && ctx.response[refKey];\n      }\n    });\n  }\n  return fetchError;\n}\n\nconst payloadMethods = new Set(\n  Object.freeze([\"PATCH\", \"POST\", \"PUT\", \"DELETE\"])\n);\nfunction isPayloadMethod(method = \"GET\") {\n  return payloadMethods.has(method.toUpperCase());\n}\nfunction isJSONSerializable(value) {\n  if (value === void 0) {\n    return false;\n  }\n  const t = typeof value;\n  if (t === \"string\" || t === \"number\" || t === \"boolean\" || t === null) {\n    return true;\n  }\n  if (t !== \"object\") {\n    return false;\n  }\n  if (Array.isArray(value)) {\n    return true;\n  }\n  if (value.buffer) {\n    return false;\n  }\n  return value.constructor && value.constructor.name === \"Object\" || typeof value.toJSON === \"function\";\n}\nconst textTypes = /* @__PURE__ */ new Set([\n  \"image/svg\",\n  \"application/xml\",\n  \"application/xhtml\",\n  \"application/html\"\n]);\nconst JSON_RE = /^application\\/(?:[\\w!#$%&*.^`~-]*\\+)?json(;.+)?$/i;\nfunction detectResponseType(_contentType = \"\") {\n  if (!_contentType) {\n    return \"json\";\n  }\n  const contentType = _contentType.split(\";\").shift() || \"\";\n  if (JSON_RE.test(contentType)) {\n    return \"json\";\n  }\n  if (textTypes.has(contentType) || contentType.startsWith(\"text/\")) {\n    return \"text\";\n  }\n  return \"blob\";\n}\nfunction resolveFetchOptions(request, input, defaults, Headers) {\n  const headers = mergeHeaders(\n    input?.headers ?? request?.headers,\n    defaults?.headers,\n    Headers\n  );\n  let query;\n  if (defaults?.query || defaults?.params || input?.params || input?.query) {\n    query = {\n      ...defaults?.params,\n      ...defaults?.query,\n      ...input?.params,\n      ...input?.query\n    };\n  }\n  return {\n    ...defaults,\n    ...input,\n    query,\n    params: query,\n    headers\n  };\n}\nfunction mergeHeaders(input, defaults, Headers) {\n  if (!defaults) {\n    return new Headers(input);\n  }\n  const headers = new Headers(defaults);\n  if (input) {\n    for (const [key, value] of Symbol.iterator in input || Array.isArray(input) ? input : new Headers(input)) {\n      headers.set(key, value);\n    }\n  }\n  return headers;\n}\nasync function callHooks(context, hooks) {\n  if (hooks) {\n    if (Array.isArray(hooks)) {\n      for (const hook of hooks) {\n        await hook(context);\n      }\n    } else {\n      await hooks(context);\n    }\n  }\n}\n\nconst retryStatusCodes = /* @__PURE__ */ new Set([\n  408,\n  // Request Timeout\n  409,\n  // Conflict\n  425,\n  // Too Early (Experimental)\n  429,\n  // Too Many Requests\n  500,\n  // Internal Server Error\n  502,\n  // Bad Gateway\n  503,\n  // Service Unavailable\n  504\n  // Gateway Timeout\n]);\nconst nullBodyResponses = /* @__PURE__ */ new Set([101, 204, 205, 304]);\nfunction createFetch(globalOptions = {}) {\n  const {\n    fetch = globalThis.fetch,\n    Headers = globalThis.Headers,\n    AbortController = globalThis.AbortController\n  } = globalOptions;\n  async function onError(context) {\n    const isAbort = context.error && context.error.name === \"AbortError\" && !context.options.timeout || false;\n    if (context.options.retry !== false && !isAbort) {\n      let retries;\n      if (typeof context.options.retry === \"number\") {\n        retries = context.options.retry;\n      } else {\n        retries = isPayloadMethod(context.options.method) ? 0 : 1;\n      }\n      const responseCode = context.response && context.response.status || 500;\n      if (retries > 0 && (Array.isArray(context.options.retryStatusCodes) ? context.options.retryStatusCodes.includes(responseCode) : retryStatusCodes.has(responseCode))) {\n        const retryDelay = typeof context.options.retryDelay === \"function\" ? context.options.retryDelay(context) : context.options.retryDelay || 0;\n        if (retryDelay > 0) {\n          await new Promise((resolve) => setTimeout(resolve, retryDelay));\n        }\n        return $fetchRaw(context.request, {\n          ...context.options,\n          retry: retries - 1\n        });\n      }\n    }\n    const error = createFetchError(context);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(error, $fetchRaw);\n    }\n    throw error;\n  }\n  const $fetchRaw = async function $fetchRaw2(_request, _options = {}) {\n    const context = {\n      request: _request,\n      options: resolveFetchOptions(\n        _request,\n        _options,\n        globalOptions.defaults,\n        Headers\n      ),\n      response: void 0,\n      error: void 0\n    };\n    if (context.options.method) {\n      context.options.method = context.options.method.toUpperCase();\n    }\n    if (context.options.onRequest) {\n      await callHooks(context, context.options.onRequest);\n    }\n    if (typeof context.request === \"string\") {\n      if (context.options.baseURL) {\n        context.request = (0,ufo__WEBPACK_IMPORTED_MODULE_1__.withBase)(context.request, context.options.baseURL);\n      }\n      if (context.options.query) {\n        context.request = (0,ufo__WEBPACK_IMPORTED_MODULE_1__.withQuery)(context.request, context.options.query);\n        delete context.options.query;\n      }\n      if (\"query\" in context.options) {\n        delete context.options.query;\n      }\n      if (\"params\" in context.options) {\n        delete context.options.params;\n      }\n    }\n    if (context.options.body && isPayloadMethod(context.options.method)) {\n      if (isJSONSerializable(context.options.body)) {\n        context.options.body = typeof context.options.body === \"string\" ? context.options.body : JSON.stringify(context.options.body);\n        context.options.headers = new Headers(context.options.headers || {});\n        if (!context.options.headers.has(\"content-type\")) {\n          context.options.headers.set(\"content-type\", \"application/json\");\n        }\n        if (!context.options.headers.has(\"accept\")) {\n          context.options.headers.set(\"accept\", \"application/json\");\n        }\n      } else if (\n        // ReadableStream Body\n        \"pipeTo\" in context.options.body && typeof context.options.body.pipeTo === \"function\" || // Node.js Stream Body\n        typeof context.options.body.pipe === \"function\"\n      ) {\n        if (!(\"duplex\" in context.options)) {\n          context.options.duplex = \"half\";\n        }\n      }\n    }\n    let abortTimeout;\n    if (!context.options.signal && context.options.timeout) {\n      const controller = new AbortController();\n      abortTimeout = setTimeout(() => {\n        const error = new Error(\n          \"[TimeoutError]: The operation was aborted due to timeout\"\n        );\n        error.name = \"TimeoutError\";\n        error.code = 23;\n        controller.abort(error);\n      }, context.options.timeout);\n      context.options.signal = controller.signal;\n    }\n    try {\n      context.response = await fetch(\n        context.request,\n        context.options\n      );\n    } catch (error) {\n      context.error = error;\n      if (context.options.onRequestError) {\n        await callHooks(\n          context,\n          context.options.onRequestError\n        );\n      }\n      return await onError(context);\n    } finally {\n      if (abortTimeout) {\n        clearTimeout(abortTimeout);\n      }\n    }\n    const hasBody = (context.response.body || // https://github.com/unjs/ofetch/issues/324\n    // https://github.com/unjs/ofetch/issues/294\n    // https://github.com/JakeChampion/fetch/issues/1454\n    context.response._bodyInit) && !nullBodyResponses.has(context.response.status) && context.options.method !== \"HEAD\";\n    if (hasBody) {\n      const responseType = (context.options.parseResponse ? \"json\" : context.options.responseType) || detectResponseType(context.response.headers.get(\"content-type\") || \"\");\n      switch (responseType) {\n        case \"json\": {\n          const data = await context.response.text();\n          const parseFunction = context.options.parseResponse || destr__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n          context.response._data = parseFunction(data);\n          break;\n        }\n        case \"stream\": {\n          context.response._data = context.response.body || context.response._bodyInit;\n          break;\n        }\n        default: {\n          context.response._data = await context.response[responseType]();\n        }\n      }\n    }\n    if (context.options.onResponse) {\n      await callHooks(\n        context,\n        context.options.onResponse\n      );\n    }\n    if (!context.options.ignoreResponseError && context.response.status >= 400 && context.response.status < 600) {\n      if (context.options.onResponseError) {\n        await callHooks(\n          context,\n          context.options.onResponseError\n        );\n      }\n      return await onError(context);\n    }\n    return context.response;\n  };\n  const $fetch = async function $fetch2(request, options) {\n    const r = await $fetchRaw(request, options);\n    return r._data;\n  };\n  $fetch.raw = $fetchRaw;\n  $fetch.native = (...args) => fetch(...args);\n  $fetch.create = (defaultOptions = {}, customGlobalOptions = {}) => createFetch({\n    ...globalOptions,\n    ...customGlobalOptions,\n    defaults: {\n      ...globalOptions.defaults,\n      ...customGlobalOptions.defaults,\n      ...defaultOptions\n    }\n  });\n  return $fetch;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb2ZldGNoL2Rpc3Qvc2hhcmVkL29mZXRjaC4wMzg4N2ZjMy5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBMEI7QUFDZ0I7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLE9BQU8sSUFBSSxvQkFBb0I7QUFDeEQsc0NBQXNDLHFCQUFxQixFQUFFLHdCQUF3QjtBQUNyRixxQkFBcUIsV0FBVyxJQUFJLFVBQVUsRUFBRSxtQkFBbUIsYUFBYSxPQUFPO0FBQ3ZGO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUU7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsNkNBQVE7QUFDbEM7QUFDQTtBQUNBLDBCQUEwQiw4Q0FBUztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsNkNBQUs7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQywwQkFBMEI7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFb0UiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hcmlpZWxsdXNkZXYvRG9jdW1lbnRzL0Rldk9wcy9IYWNrYXRob24vbW9kZXJJQS1BSXRyaWZlY3RhL25vZGVfbW9kdWxlcy9vZmV0Y2gvZGlzdC9zaGFyZWQvb2ZldGNoLjAzODg3ZmMzLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZGVzdHIgZnJvbSAnZGVzdHInO1xuaW1wb3J0IHsgd2l0aEJhc2UsIHdpdGhRdWVyeSB9IGZyb20gJ3Vmbyc7XG5cbmNsYXNzIEZldGNoRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIG9wdHMpIHtcbiAgICBzdXBlcihtZXNzYWdlLCBvcHRzKTtcbiAgICB0aGlzLm5hbWUgPSBcIkZldGNoRXJyb3JcIjtcbiAgICBpZiAob3B0cz8uY2F1c2UgJiYgIXRoaXMuY2F1c2UpIHtcbiAgICAgIHRoaXMuY2F1c2UgPSBvcHRzLmNhdXNlO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlRmV0Y2hFcnJvcihjdHgpIHtcbiAgY29uc3QgZXJyb3JNZXNzYWdlID0gY3R4LmVycm9yPy5tZXNzYWdlIHx8IGN0eC5lcnJvcj8udG9TdHJpbmcoKSB8fCBcIlwiO1xuICBjb25zdCBtZXRob2QgPSBjdHgucmVxdWVzdD8ubWV0aG9kIHx8IGN0eC5vcHRpb25zPy5tZXRob2QgfHwgXCJHRVRcIjtcbiAgY29uc3QgdXJsID0gY3R4LnJlcXVlc3Q/LnVybCB8fCBTdHJpbmcoY3R4LnJlcXVlc3QpIHx8IFwiL1wiO1xuICBjb25zdCByZXF1ZXN0U3RyID0gYFske21ldGhvZH1dICR7SlNPTi5zdHJpbmdpZnkodXJsKX1gO1xuICBjb25zdCBzdGF0dXNTdHIgPSBjdHgucmVzcG9uc2UgPyBgJHtjdHgucmVzcG9uc2Uuc3RhdHVzfSAke2N0eC5yZXNwb25zZS5zdGF0dXNUZXh0fWAgOiBcIjxubyByZXNwb25zZT5cIjtcbiAgY29uc3QgbWVzc2FnZSA9IGAke3JlcXVlc3RTdHJ9OiAke3N0YXR1c1N0cn0ke2Vycm9yTWVzc2FnZSA/IGAgJHtlcnJvck1lc3NhZ2V9YCA6IFwiXCJ9YDtcbiAgY29uc3QgZmV0Y2hFcnJvciA9IG5ldyBGZXRjaEVycm9yKFxuICAgIG1lc3NhZ2UsXG4gICAgY3R4LmVycm9yID8geyBjYXVzZTogY3R4LmVycm9yIH0gOiB2b2lkIDBcbiAgKTtcbiAgZm9yIChjb25zdCBrZXkgb2YgW1wicmVxdWVzdFwiLCBcIm9wdGlvbnNcIiwgXCJyZXNwb25zZVwiXSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmZXRjaEVycm9yLCBrZXksIHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIGN0eFtrZXldO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGZvciAoY29uc3QgW2tleSwgcmVmS2V5XSBvZiBbXG4gICAgW1wiZGF0YVwiLCBcIl9kYXRhXCJdLFxuICAgIFtcInN0YXR1c1wiLCBcInN0YXR1c1wiXSxcbiAgICBbXCJzdGF0dXNDb2RlXCIsIFwic3RhdHVzXCJdLFxuICAgIFtcInN0YXR1c1RleHRcIiwgXCJzdGF0dXNUZXh0XCJdLFxuICAgIFtcInN0YXR1c01lc3NhZ2VcIiwgXCJzdGF0dXNUZXh0XCJdXG4gIF0pIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZmV0Y2hFcnJvciwga2V5LCB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiBjdHgucmVzcG9uc2UgJiYgY3R4LnJlc3BvbnNlW3JlZktleV07XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGZldGNoRXJyb3I7XG59XG5cbmNvbnN0IHBheWxvYWRNZXRob2RzID0gbmV3IFNldChcbiAgT2JqZWN0LmZyZWV6ZShbXCJQQVRDSFwiLCBcIlBPU1RcIiwgXCJQVVRcIiwgXCJERUxFVEVcIl0pXG4pO1xuZnVuY3Rpb24gaXNQYXlsb2FkTWV0aG9kKG1ldGhvZCA9IFwiR0VUXCIpIHtcbiAgcmV0dXJuIHBheWxvYWRNZXRob2RzLmhhcyhtZXRob2QudG9VcHBlckNhc2UoKSk7XG59XG5mdW5jdGlvbiBpc0pTT05TZXJpYWxpemFibGUodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgdCA9IHR5cGVvZiB2YWx1ZTtcbiAgaWYgKHQgPT09IFwic3RyaW5nXCIgfHwgdCA9PT0gXCJudW1iZXJcIiB8fCB0ID09PSBcImJvb2xlYW5cIiB8fCB0ID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHQgIT09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHZhbHVlLmJ1ZmZlcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IubmFtZSA9PT0gXCJPYmplY3RcIiB8fCB0eXBlb2YgdmFsdWUudG9KU09OID09PSBcImZ1bmN0aW9uXCI7XG59XG5jb25zdCB0ZXh0VHlwZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXG4gIFwiaW1hZ2Uvc3ZnXCIsXG4gIFwiYXBwbGljYXRpb24veG1sXCIsXG4gIFwiYXBwbGljYXRpb24veGh0bWxcIixcbiAgXCJhcHBsaWNhdGlvbi9odG1sXCJcbl0pO1xuY29uc3QgSlNPTl9SRSA9IC9eYXBwbGljYXRpb25cXC8oPzpbXFx3ISMkJSYqLl5gfi1dKlxcKyk/anNvbig7LispPyQvaTtcbmZ1bmN0aW9uIGRldGVjdFJlc3BvbnNlVHlwZShfY29udGVudFR5cGUgPSBcIlwiKSB7XG4gIGlmICghX2NvbnRlbnRUeXBlKSB7XG4gICAgcmV0dXJuIFwianNvblwiO1xuICB9XG4gIGNvbnN0IGNvbnRlbnRUeXBlID0gX2NvbnRlbnRUeXBlLnNwbGl0KFwiO1wiKS5zaGlmdCgpIHx8IFwiXCI7XG4gIGlmIChKU09OX1JFLnRlc3QoY29udGVudFR5cGUpKSB7XG4gICAgcmV0dXJuIFwianNvblwiO1xuICB9XG4gIGlmICh0ZXh0VHlwZXMuaGFzKGNvbnRlbnRUeXBlKSB8fCBjb250ZW50VHlwZS5zdGFydHNXaXRoKFwidGV4dC9cIikpIHtcbiAgICByZXR1cm4gXCJ0ZXh0XCI7XG4gIH1cbiAgcmV0dXJuIFwiYmxvYlwiO1xufVxuZnVuY3Rpb24gcmVzb2x2ZUZldGNoT3B0aW9ucyhyZXF1ZXN0LCBpbnB1dCwgZGVmYXVsdHMsIEhlYWRlcnMpIHtcbiAgY29uc3QgaGVhZGVycyA9IG1lcmdlSGVhZGVycyhcbiAgICBpbnB1dD8uaGVhZGVycyA/PyByZXF1ZXN0Py5oZWFkZXJzLFxuICAgIGRlZmF1bHRzPy5oZWFkZXJzLFxuICAgIEhlYWRlcnNcbiAgKTtcbiAgbGV0IHF1ZXJ5O1xuICBpZiAoZGVmYXVsdHM/LnF1ZXJ5IHx8IGRlZmF1bHRzPy5wYXJhbXMgfHwgaW5wdXQ/LnBhcmFtcyB8fCBpbnB1dD8ucXVlcnkpIHtcbiAgICBxdWVyeSA9IHtcbiAgICAgIC4uLmRlZmF1bHRzPy5wYXJhbXMsXG4gICAgICAuLi5kZWZhdWx0cz8ucXVlcnksXG4gICAgICAuLi5pbnB1dD8ucGFyYW1zLFxuICAgICAgLi4uaW5wdXQ/LnF1ZXJ5XG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIC4uLmRlZmF1bHRzLFxuICAgIC4uLmlucHV0LFxuICAgIHF1ZXJ5LFxuICAgIHBhcmFtczogcXVlcnksXG4gICAgaGVhZGVyc1xuICB9O1xufVxuZnVuY3Rpb24gbWVyZ2VIZWFkZXJzKGlucHV0LCBkZWZhdWx0cywgSGVhZGVycykge1xuICBpZiAoIWRlZmF1bHRzKSB7XG4gICAgcmV0dXJuIG5ldyBIZWFkZXJzKGlucHV0KTtcbiAgfVxuICBjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoZGVmYXVsdHMpO1xuICBpZiAoaW5wdXQpIHtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBTeW1ib2wuaXRlcmF0b3IgaW4gaW5wdXQgfHwgQXJyYXkuaXNBcnJheShpbnB1dCkgPyBpbnB1dCA6IG5ldyBIZWFkZXJzKGlucHV0KSkge1xuICAgICAgaGVhZGVycy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBoZWFkZXJzO1xufVxuYXN5bmMgZnVuY3Rpb24gY2FsbEhvb2tzKGNvbnRleHQsIGhvb2tzKSB7XG4gIGlmIChob29rcykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGhvb2tzKSkge1xuICAgICAgZm9yIChjb25zdCBob29rIG9mIGhvb2tzKSB7XG4gICAgICAgIGF3YWl0IGhvb2soY29udGV4dCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGF3YWl0IGhvb2tzKGNvbnRleHQpO1xuICAgIH1cbiAgfVxufVxuXG5jb25zdCByZXRyeVN0YXR1c0NvZGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1xuICA0MDgsXG4gIC8vIFJlcXVlc3QgVGltZW91dFxuICA0MDksXG4gIC8vIENvbmZsaWN0XG4gIDQyNSxcbiAgLy8gVG9vIEVhcmx5IChFeHBlcmltZW50YWwpXG4gIDQyOSxcbiAgLy8gVG9vIE1hbnkgUmVxdWVzdHNcbiAgNTAwLFxuICAvLyBJbnRlcm5hbCBTZXJ2ZXIgRXJyb3JcbiAgNTAyLFxuICAvLyBCYWQgR2F0ZXdheVxuICA1MDMsXG4gIC8vIFNlcnZpY2UgVW5hdmFpbGFibGVcbiAgNTA0XG4gIC8vIEdhdGV3YXkgVGltZW91dFxuXSk7XG5jb25zdCBudWxsQm9keVJlc3BvbnNlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFsxMDEsIDIwNCwgMjA1LCAzMDRdKTtcbmZ1bmN0aW9uIGNyZWF0ZUZldGNoKGdsb2JhbE9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgZmV0Y2ggPSBnbG9iYWxUaGlzLmZldGNoLFxuICAgIEhlYWRlcnMgPSBnbG9iYWxUaGlzLkhlYWRlcnMsXG4gICAgQWJvcnRDb250cm9sbGVyID0gZ2xvYmFsVGhpcy5BYm9ydENvbnRyb2xsZXJcbiAgfSA9IGdsb2JhbE9wdGlvbnM7XG4gIGFzeW5jIGZ1bmN0aW9uIG9uRXJyb3IoY29udGV4dCkge1xuICAgIGNvbnN0IGlzQWJvcnQgPSBjb250ZXh0LmVycm9yICYmIGNvbnRleHQuZXJyb3IubmFtZSA9PT0gXCJBYm9ydEVycm9yXCIgJiYgIWNvbnRleHQub3B0aW9ucy50aW1lb3V0IHx8IGZhbHNlO1xuICAgIGlmIChjb250ZXh0Lm9wdGlvbnMucmV0cnkgIT09IGZhbHNlICYmICFpc0Fib3J0KSB7XG4gICAgICBsZXQgcmV0cmllcztcbiAgICAgIGlmICh0eXBlb2YgY29udGV4dC5vcHRpb25zLnJldHJ5ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJldHJpZXMgPSBjb250ZXh0Lm9wdGlvbnMucmV0cnk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXRyaWVzID0gaXNQYXlsb2FkTWV0aG9kKGNvbnRleHQub3B0aW9ucy5tZXRob2QpID8gMCA6IDE7XG4gICAgICB9XG4gICAgICBjb25zdCByZXNwb25zZUNvZGUgPSBjb250ZXh0LnJlc3BvbnNlICYmIGNvbnRleHQucmVzcG9uc2Uuc3RhdHVzIHx8IDUwMDtcbiAgICAgIGlmIChyZXRyaWVzID4gMCAmJiAoQXJyYXkuaXNBcnJheShjb250ZXh0Lm9wdGlvbnMucmV0cnlTdGF0dXNDb2RlcykgPyBjb250ZXh0Lm9wdGlvbnMucmV0cnlTdGF0dXNDb2Rlcy5pbmNsdWRlcyhyZXNwb25zZUNvZGUpIDogcmV0cnlTdGF0dXNDb2Rlcy5oYXMocmVzcG9uc2VDb2RlKSkpIHtcbiAgICAgICAgY29uc3QgcmV0cnlEZWxheSA9IHR5cGVvZiBjb250ZXh0Lm9wdGlvbnMucmV0cnlEZWxheSA9PT0gXCJmdW5jdGlvblwiID8gY29udGV4dC5vcHRpb25zLnJldHJ5RGVsYXkoY29udGV4dCkgOiBjb250ZXh0Lm9wdGlvbnMucmV0cnlEZWxheSB8fCAwO1xuICAgICAgICBpZiAocmV0cnlEZWxheSA+IDApIHtcbiAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCByZXRyeURlbGF5KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICRmZXRjaFJhdyhjb250ZXh0LnJlcXVlc3QsIHtcbiAgICAgICAgICAuLi5jb250ZXh0Lm9wdGlvbnMsXG4gICAgICAgICAgcmV0cnk6IHJldHJpZXMgLSAxXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBlcnJvciA9IGNyZWF0ZUZldGNoRXJyb3IoY29udGV4dCk7XG4gICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShlcnJvciwgJGZldGNoUmF3KTtcbiAgICB9XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbiAgY29uc3QgJGZldGNoUmF3ID0gYXN5bmMgZnVuY3Rpb24gJGZldGNoUmF3MihfcmVxdWVzdCwgX29wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICByZXF1ZXN0OiBfcmVxdWVzdCxcbiAgICAgIG9wdGlvbnM6IHJlc29sdmVGZXRjaE9wdGlvbnMoXG4gICAgICAgIF9yZXF1ZXN0LFxuICAgICAgICBfb3B0aW9ucyxcbiAgICAgICAgZ2xvYmFsT3B0aW9ucy5kZWZhdWx0cyxcbiAgICAgICAgSGVhZGVyc1xuICAgICAgKSxcbiAgICAgIHJlc3BvbnNlOiB2b2lkIDAsXG4gICAgICBlcnJvcjogdm9pZCAwXG4gICAgfTtcbiAgICBpZiAoY29udGV4dC5vcHRpb25zLm1ldGhvZCkge1xuICAgICAgY29udGV4dC5vcHRpb25zLm1ldGhvZCA9IGNvbnRleHQub3B0aW9ucy5tZXRob2QudG9VcHBlckNhc2UoKTtcbiAgICB9XG4gICAgaWYgKGNvbnRleHQub3B0aW9ucy5vblJlcXVlc3QpIHtcbiAgICAgIGF3YWl0IGNhbGxIb29rcyhjb250ZXh0LCBjb250ZXh0Lm9wdGlvbnMub25SZXF1ZXN0KTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjb250ZXh0LnJlcXVlc3QgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGlmIChjb250ZXh0Lm9wdGlvbnMuYmFzZVVSTCkge1xuICAgICAgICBjb250ZXh0LnJlcXVlc3QgPSB3aXRoQmFzZShjb250ZXh0LnJlcXVlc3QsIGNvbnRleHQub3B0aW9ucy5iYXNlVVJMKTtcbiAgICAgIH1cbiAgICAgIGlmIChjb250ZXh0Lm9wdGlvbnMucXVlcnkpIHtcbiAgICAgICAgY29udGV4dC5yZXF1ZXN0ID0gd2l0aFF1ZXJ5KGNvbnRleHQucmVxdWVzdCwgY29udGV4dC5vcHRpb25zLnF1ZXJ5KTtcbiAgICAgICAgZGVsZXRlIGNvbnRleHQub3B0aW9ucy5xdWVyeTtcbiAgICAgIH1cbiAgICAgIGlmIChcInF1ZXJ5XCIgaW4gY29udGV4dC5vcHRpb25zKSB7XG4gICAgICAgIGRlbGV0ZSBjb250ZXh0Lm9wdGlvbnMucXVlcnk7XG4gICAgICB9XG4gICAgICBpZiAoXCJwYXJhbXNcIiBpbiBjb250ZXh0Lm9wdGlvbnMpIHtcbiAgICAgICAgZGVsZXRlIGNvbnRleHQub3B0aW9ucy5wYXJhbXM7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjb250ZXh0Lm9wdGlvbnMuYm9keSAmJiBpc1BheWxvYWRNZXRob2QoY29udGV4dC5vcHRpb25zLm1ldGhvZCkpIHtcbiAgICAgIGlmIChpc0pTT05TZXJpYWxpemFibGUoY29udGV4dC5vcHRpb25zLmJvZHkpKSB7XG4gICAgICAgIGNvbnRleHQub3B0aW9ucy5ib2R5ID0gdHlwZW9mIGNvbnRleHQub3B0aW9ucy5ib2R5ID09PSBcInN0cmluZ1wiID8gY29udGV4dC5vcHRpb25zLmJvZHkgOiBKU09OLnN0cmluZ2lmeShjb250ZXh0Lm9wdGlvbnMuYm9keSk7XG4gICAgICAgIGNvbnRleHQub3B0aW9ucy5oZWFkZXJzID0gbmV3IEhlYWRlcnMoY29udGV4dC5vcHRpb25zLmhlYWRlcnMgfHwge30pO1xuICAgICAgICBpZiAoIWNvbnRleHQub3B0aW9ucy5oZWFkZXJzLmhhcyhcImNvbnRlbnQtdHlwZVwiKSkge1xuICAgICAgICAgIGNvbnRleHQub3B0aW9ucy5oZWFkZXJzLnNldChcImNvbnRlbnQtdHlwZVwiLCBcImFwcGxpY2F0aW9uL2pzb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb250ZXh0Lm9wdGlvbnMuaGVhZGVycy5oYXMoXCJhY2NlcHRcIikpIHtcbiAgICAgICAgICBjb250ZXh0Lm9wdGlvbnMuaGVhZGVycy5zZXQoXCJhY2NlcHRcIiwgXCJhcHBsaWNhdGlvbi9qc29uXCIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAvLyBSZWFkYWJsZVN0cmVhbSBCb2R5XG4gICAgICAgIFwicGlwZVRvXCIgaW4gY29udGV4dC5vcHRpb25zLmJvZHkgJiYgdHlwZW9mIGNvbnRleHQub3B0aW9ucy5ib2R5LnBpcGVUbyA9PT0gXCJmdW5jdGlvblwiIHx8IC8vIE5vZGUuanMgU3RyZWFtIEJvZHlcbiAgICAgICAgdHlwZW9mIGNvbnRleHQub3B0aW9ucy5ib2R5LnBpcGUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgKSB7XG4gICAgICAgIGlmICghKFwiZHVwbGV4XCIgaW4gY29udGV4dC5vcHRpb25zKSkge1xuICAgICAgICAgIGNvbnRleHQub3B0aW9ucy5kdXBsZXggPSBcImhhbGZcIjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBsZXQgYWJvcnRUaW1lb3V0O1xuICAgIGlmICghY29udGV4dC5vcHRpb25zLnNpZ25hbCAmJiBjb250ZXh0Lm9wdGlvbnMudGltZW91dCkge1xuICAgICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgIGFib3J0VGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgICBcIltUaW1lb3V0RXJyb3JdOiBUaGUgb3BlcmF0aW9uIHdhcyBhYm9ydGVkIGR1ZSB0byB0aW1lb3V0XCJcbiAgICAgICAgKTtcbiAgICAgICAgZXJyb3IubmFtZSA9IFwiVGltZW91dEVycm9yXCI7XG4gICAgICAgIGVycm9yLmNvZGUgPSAyMztcbiAgICAgICAgY29udHJvbGxlci5hYm9ydChlcnJvcik7XG4gICAgICB9LCBjb250ZXh0Lm9wdGlvbnMudGltZW91dCk7XG4gICAgICBjb250ZXh0Lm9wdGlvbnMuc2lnbmFsID0gY29udHJvbGxlci5zaWduYWw7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb250ZXh0LnJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXG4gICAgICAgIGNvbnRleHQucmVxdWVzdCxcbiAgICAgICAgY29udGV4dC5vcHRpb25zXG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb250ZXh0LmVycm9yID0gZXJyb3I7XG4gICAgICBpZiAoY29udGV4dC5vcHRpb25zLm9uUmVxdWVzdEVycm9yKSB7XG4gICAgICAgIGF3YWl0IGNhbGxIb29rcyhcbiAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgIGNvbnRleHQub3B0aW9ucy5vblJlcXVlc3RFcnJvclxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGF3YWl0IG9uRXJyb3IoY29udGV4dCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChhYm9ydFRpbWVvdXQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGFib3J0VGltZW91dCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGhhc0JvZHkgPSAoY29udGV4dC5yZXNwb25zZS5ib2R5IHx8IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS91bmpzL29mZXRjaC9pc3N1ZXMvMzI0XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3VuanMvb2ZldGNoL2lzc3Vlcy8yOTRcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vSmFrZUNoYW1waW9uL2ZldGNoL2lzc3Vlcy8xNDU0XG4gICAgY29udGV4dC5yZXNwb25zZS5fYm9keUluaXQpICYmICFudWxsQm9keVJlc3BvbnNlcy5oYXMoY29udGV4dC5yZXNwb25zZS5zdGF0dXMpICYmIGNvbnRleHQub3B0aW9ucy5tZXRob2QgIT09IFwiSEVBRFwiO1xuICAgIGlmIChoYXNCb2R5KSB7XG4gICAgICBjb25zdCByZXNwb25zZVR5cGUgPSAoY29udGV4dC5vcHRpb25zLnBhcnNlUmVzcG9uc2UgPyBcImpzb25cIiA6IGNvbnRleHQub3B0aW9ucy5yZXNwb25zZVR5cGUpIHx8IGRldGVjdFJlc3BvbnNlVHlwZShjb250ZXh0LnJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiY29udGVudC10eXBlXCIpIHx8IFwiXCIpO1xuICAgICAgc3dpdGNoIChyZXNwb25zZVR5cGUpIHtcbiAgICAgICAgY2FzZSBcImpzb25cIjoge1xuICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBjb250ZXh0LnJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgICBjb25zdCBwYXJzZUZ1bmN0aW9uID0gY29udGV4dC5vcHRpb25zLnBhcnNlUmVzcG9uc2UgfHwgZGVzdHI7XG4gICAgICAgICAgY29udGV4dC5yZXNwb25zZS5fZGF0YSA9IHBhcnNlRnVuY3Rpb24oZGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcInN0cmVhbVwiOiB7XG4gICAgICAgICAgY29udGV4dC5yZXNwb25zZS5fZGF0YSA9IGNvbnRleHQucmVzcG9uc2UuYm9keSB8fCBjb250ZXh0LnJlc3BvbnNlLl9ib2R5SW5pdDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgY29udGV4dC5yZXNwb25zZS5fZGF0YSA9IGF3YWl0IGNvbnRleHQucmVzcG9uc2VbcmVzcG9uc2VUeXBlXSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjb250ZXh0Lm9wdGlvbnMub25SZXNwb25zZSkge1xuICAgICAgYXdhaXQgY2FsbEhvb2tzKFxuICAgICAgICBjb250ZXh0LFxuICAgICAgICBjb250ZXh0Lm9wdGlvbnMub25SZXNwb25zZVxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKCFjb250ZXh0Lm9wdGlvbnMuaWdub3JlUmVzcG9uc2VFcnJvciAmJiBjb250ZXh0LnJlc3BvbnNlLnN0YXR1cyA+PSA0MDAgJiYgY29udGV4dC5yZXNwb25zZS5zdGF0dXMgPCA2MDApIHtcbiAgICAgIGlmIChjb250ZXh0Lm9wdGlvbnMub25SZXNwb25zZUVycm9yKSB7XG4gICAgICAgIGF3YWl0IGNhbGxIb29rcyhcbiAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgIGNvbnRleHQub3B0aW9ucy5vblJlc3BvbnNlRXJyb3JcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhd2FpdCBvbkVycm9yKGNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gY29udGV4dC5yZXNwb25zZTtcbiAgfTtcbiAgY29uc3QgJGZldGNoID0gYXN5bmMgZnVuY3Rpb24gJGZldGNoMihyZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgY29uc3QgciA9IGF3YWl0ICRmZXRjaFJhdyhyZXF1ZXN0LCBvcHRpb25zKTtcbiAgICByZXR1cm4gci5fZGF0YTtcbiAgfTtcbiAgJGZldGNoLnJhdyA9ICRmZXRjaFJhdztcbiAgJGZldGNoLm5hdGl2ZSA9ICguLi5hcmdzKSA9PiBmZXRjaCguLi5hcmdzKTtcbiAgJGZldGNoLmNyZWF0ZSA9IChkZWZhdWx0T3B0aW9ucyA9IHt9LCBjdXN0b21HbG9iYWxPcHRpb25zID0ge30pID0+IGNyZWF0ZUZldGNoKHtcbiAgICAuLi5nbG9iYWxPcHRpb25zLFxuICAgIC4uLmN1c3RvbUdsb2JhbE9wdGlvbnMsXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgIC4uLmdsb2JhbE9wdGlvbnMuZGVmYXVsdHMsXG4gICAgICAuLi5jdXN0b21HbG9iYWxPcHRpb25zLmRlZmF1bHRzLFxuICAgICAgLi4uZGVmYXVsdE9wdGlvbnNcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gJGZldGNoO1xufVxuXG5leHBvcnQgeyBGZXRjaEVycm9yIGFzIEYsIGNyZWF0ZUZldGNoRXJyb3IgYXMgYSwgY3JlYXRlRmV0Y2ggYXMgYyB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ofetch/dist/shared/ofetch.03887fc3.mjs\n");

/***/ })

};
;